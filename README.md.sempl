#!/usr/bin/env sempl
SEMPL_BRACES='<>'
var = value
var1='value'
var2='this value'\''s got a quote in the middle'
var3='escaped quotes aren'\\''t pretty, but they'\\''re possible'
bar='==='
# other ideas
#n=$'\n'
#t=$'\t'
#lb='{'
#rb='}'
#ln=$.
#SEMPL_IFS="\s+"
#SEMPL_OFS=" "
#!end sempl env

# Sempl

A simple, line-oriented template utility for the command line.
Useful for injecting command output, file contents,
and environment variables into arbitrary text.

## Comments: {#comment}

    Want to know a secret? {#This text won't render}

renders as

    Want to know a secret? <#This text won't render>

Sempl templates are evaluated line by line,
and parameters such as the comment above must begin and end on the same line,
so the following would be rendered as-is:

    {# you might think
     # this would be
     # a multiline comment,
     # but you'd be wrong }

<!-- test
    {# you might think
     # this would be
     # a multiline comment,
     # but you'd be wrong }
-->

## Basic Parameters

### Environment Variables: {$envvar}

    My shell is {$SHELL}

on my system, renders as

    My shell is <$SHELL>

### Files: {/file} or {.file}<# or {~file}>

Suppose we have a file in `/tmp` named `hello.txt`
with the following contents.

    <./hello.txt>

In that case,

    ==> {/tmp/hello.txt} <==

renders as

    ==> <./hello.txt> <==

This also works with relative paths that start with `.` <#and home directories>.

    {.dotfile}
    {./file}
    {./path/to/file}
<#    {~/path/to/file/in/home} >
<#    {~user/path/to/file/in/user/home} >

Note that each line of the file is interpolated into the line in the template.
All basic parameters -- `{$envvar} {/file} {!command} {-}` --
undergo line interpolation.

### Commands: {!command}

    > {!grep -x s.mple /usr/share/dict/words | sed 'p; s/$/r/'}

on my system, renders as

    > <!grep -x s.mple /usr/share/dict/words | sed 'p; s/$/r/'>

Only stdin is captured.
To capture stderr, use shell redirection.

### Stdin: {-}

	$ echo -e 'en\nid\nic' | sempl 'V{-}i,'
	<!echo -e 'en\nid\nic' | SEMPL_BRACES='{}' ./bin/sempl 'V{-}i,'>

## Frontmatter: #!sempl

Similar to some other templating systems,
sempl templates can include a front matter at the beginning.
The front matter's first and last lines must start with `#!` and contain `sempl`.
Every other line between them either defines an environment variable,
or is a comment starting with `#`.
For example:

    #!/usr/bin/env sempl
    # export value to $var
    var = <$var>
    #!end sempl env

The above example exports `value` to the `$var` environment variable.
The template can then reference it with `{$var}`
or in commands with e.g. `{!command $var}`.

To ease copying and pasting between shell scripts,
you can wrap the value in single quotes.
Unlike in shell, quotes in the middle of unquoted values are interpreted literally.

    var1='<$var1>'
    var2='<$var2>'

Quotes in quoted strings can be escaped in a way that the shell will understand.

    var3='<$var3>'

## Fields: {<$envvar} {<!command} {</file} {<.file} {<-} {N,N:,N:M,:M,...}

`{<param}` produces no output by itself.
Instead, it interpolates fields from each line of `{param}`
into the template's current line using a cut-like syntax.

For example, suppose we have the following in `./madlibs.dat`:

    <./madlibs.dat>

In that case,

    {<./madlibs.dat}The {:2} {3} the {4:5} and {6:}.

renders as

    <<./madlibs.dat>The <:2> <3> the <4:5> and <6:>.

`{0}` expands to the whole line.
`{N}` expands to the Nth field.
Field ranges can be selected using `{N:}`, `{N:M}`, and `{:M}`.
Multiple field ranges can be expanded using commas.
For example, `{:3,5,7:}` would expand to the first through third,
fifth, and seventh through last fields.

<!--
## Line Continuation

    {$SHELL}> {!echo -e 'a\nb\nc'}. {./hello.txt}

can be rewritten as

    {$SHELL}> {\}
    {!echo -e 'a\nb\nc'}. {\}
    {./hello.txt}

Both render as

    <$SHELL>> <\>
    <!echo -e 'a\nb\nc'>. <\>
    <./hello.txt>

There's also a variant form of line continuation
that doesn't clobber newlines.

    #!/usr/bin/env sempl
    bar='==='
    #!end sempl env
    {!echo -e 'one\ntwo\nthree'}{\\}
    {$bar}

renders as

    <!SEMPL_BRACES={} sempl $'{!echo -e "one\\\\ntwo\\\\nthree"}{\\\\\\\\}\n{$bar}'>



## Running Sempl

## Nesting

## Joins

TODO: explore different kinds of join-like expressions

## Examples
-->

<!-- vim: ft=markdown
-->
