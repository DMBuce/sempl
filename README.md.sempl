#!/usr/bin/env sempl
SEMPL_OPEN='<'
SEMPL_CLOSE='>'
var = value
var1='value'
var2='this value'\''s got a quote in the middle'
var3='escaped quotes aren'\\''t pretty, but they'\\''re possible'
# other ideas
#n=$'\n'
#t=$'\t'
#lb='{'
#rb='}'
#ln=$.
#SEMPL_IFS="\s+"
#SEMPL_OFS=" "
#SEMPL_DEST="s/\.template$//"
#SEMPL_CHARS="$!-#?=\<,:;1{}"
##SEMPL_CHARS="%|<@: </>"
#SEMPL_FILE="[/.]"
#SEMPL_CMD="[| ]"
#SEMPL_PARSER=default|unescape|frontmatter
#SEMPL_FLAGS=(u)nescape (e)scape (f)rontmatter (b)ody (s)trict (l)oose
#!end sempl env

# Sempl

A simple, line-based template system for the command line.
Useful for injecting command output, file contents,
and environment variables into arbitrary text.

## Comments: {#comment}

    Want to know a secret? {#This text won't render}

renders as

    Want to know a secret? <#This text won't render>

Sempl templates are evaluated line by line,
and parameters such as the comment above must begin and end on the same line,
so the following would be rendered as-is:

    {# you might think
     # this would be
     # a multiline comment,
     # but you'd be wrong }

<!-- test
    {# you might think
     # this would be
     # a multiline comment,
     # but you'd be wrong }
-->

## Basic Parameters

### Environment Variables: {$envvar}

    My shell is {$SHELL}

on my system, renders as

    My shell is <$SHELL>

### Files: {/file} or {.file}<# or {~file}>

Suppose we have a file in `/tmp` named `hello.txt`
with the following contents.

    <./hello.txt>

In that case,

    ==> {/tmp/hello.txt} <==

renders as

    ==> <./hello.txt> <==

This also works with relative paths<# starting with `.` and home directories>.

    {.dotfile}
    {./file}
    {./path/to/file}
<#    {~/path/to/file/in/home} >
<#    {~user/path/to/file/in/user/home} >

Note that each line of the file is interpolated into the line in the template.
All basic parameters -- `{$envvar} {/file} {!command} {-}` --
undergo line interpolation.

### Commands: {!command}

    > {!grep -x s.mple /usr/share/dict/words | sed 'p; s/$/r/'}

on my system, renders as

    > <!grep -x s.mple /usr/share/dict/words | sed 'p; s/$/r/'>

Only stdin is captured.
To capture stderr, use shell redirection.

### Stdin: {-}

	$ printf '%s\\n' en id ic | sempl 'V{-}i,' | sed '$s/.$/./'
	<!printf '%s\n' en id ic | SEMPL_CLOSE=} SEMPL_OPEN={ ./bin/sempl 'V{-}i,' | sed '$s/.$/./'>

## Frontmatter: #!sempl

Similar to other templating systems,
sempl templates can include a front matter at the beginning.
The front matter's first and last lines must start with `#!` and contain `sempl`.
Every other line between them either defines an environment variable,
or is a comment starting with `#`.
For example:

    #!/usr/bin/env sempl
    # export value to $var
    var = <$var>
    #!end sempl env

The above example exports `value` to the `$var` environment variable.
The template can then reference it with `{$var}`
or in commands with e.g. `{!command $var}`.

To ease copying and pasting between shell scripts,
you can wrap the value in single quotes.
Unlike in shell, quotes in the middle of unquoted values are interpreted literally.

    var1='<$var1>'
    var2='<$var2>'

Quotes in quoted strings can be escaped in a way that the shell will understand.

    var3='<$var3>'

## Loop: {<param} {N,N:,N:M,:M,...} {;<}

{<param} begins reading from {param},
but produces no output by itself.
A {;<} ends a {<param} statement.

Each line of {param}'s output is interpolated
into the text between {<param} and {;<} using a cut-like syntax.
{0} expands to the whole line.
{N} expands to the Nth field.
Field ranges can be selected using {N-}, {N-M}, and {-M}.
Multiple field ranges can be expanded using commas.
For example, {-3,5,7-} would expand to the first through third,
fifth, and seventh through last fields.

## Nesting

## Joins

TODO: explore different kinds of join-like expressions

## Full Examples

## Real World Examples

# vim: ft=markdown
