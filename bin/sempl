#!/usr/bin/perl

use strict;
use warnings;

# define some vars
my $prog = (split(/\//, $0))[-1];
my $usage = "Syntax: $prog [SRC] [DEST]\n";

# export default env vars
$ENV{SEMPL_BRACES} ||= "{}";
my $open  = substr $ENV{SEMPL_BRACES},0,length($ENV{SEMPL_BRACES})/2;
my $close = substr $ENV{SEMPL_BRACES},length($ENV{SEMPL_BRACES})/2,length($ENV{SEMPL_BRACES});
$open ||= $close;

# parse args
my $src = shift || "-";
my $dest = shift || "-";

# open input file
my $in;
if ($src =~ /\Q$open\E(.+?)\Q$close\E/) {
	open($in, "<", \$src) or die $!;
} else {
	open($in, "<", $src) or die $!;
}

# process frontmatter
my $line = <$in>;
if ($line =~ /^#!.*$prog/) {
	while ($line = <$in>) {
		# export environment variables in frontmatter
		if ($line =~ /^#!.*$prog/) {
			# read first line of body and break loop
			$line = <$in>;
			last;
		} elsif ($line =~ /^#/) {
			next;
		} elsif ($line =~ /^\s*(.*?)\s*=\s*(.*)\s*$/) {
			my $key = $1;
			my $value = $2;
			if ($value =~ /^'(.*)'$/) {
				$value = $1;
				$value =~ s/'\\''/'/g;
			}
			$ENV{$key} = $value;
			if ($key eq "SEMPL_BRACES") {
				$open  = substr $ENV{SEMPL_BRACES},0,length($ENV{SEMPL_BRACES})/2;
				$close = substr $ENV{SEMPL_BRACES},length($ENV{SEMPL_BRACES})/2,length($ENV{SEMPL_BRACES});
				$open ||= $close;
			}
			next;
		} else {
			warn "Invalid line in frontmatter: \n\t$line\n";
		}
	}
}

# create pipe attached to sh that we can send our output to
open(my $out, "|-", "/bin/sh -e") or die "$!";
#open(my $out, "|-", "/bin/cat") or die "$!";

# send all output to dest
if ($dest ne "-") {
	print $out "exec >\"$dest\"\n";
}

# process template body
do {
	# tokenize string and process it
	my $var = '';
	my $fstring = '';
	my $lvl = 0;
	chomp $line;
	#while ($line =~ /(\Q$open\E(.)(.*?)\Q$close\E|\\(.))/pg) {
	while ($line =~ /(\Q$open\E(\\{1,3})\Q$close\E$|\Q$open\E(.)(.*?)\Q$close\E)/pg) {
		my $match = $1;
		my $cont = $2;
		my $char = $3;
		my $param = $4;
		my $text = ${^PREMATCH};
		my $t = $text;
		$t =~ s/'/'\\''/g;
		$fstring .= "'$t'";
		if (defined $cont && $cont eq "\\\\\\") {
			$line = <$in>;
			$line =~ s/^\s+//;
			chomp $line;
			next;
		} elsif (defined $cont && $cont eq "\\\\") {
			$line = <$in>;
			chomp $line;
			next;
		} elsif (defined $cont && $cont eq "\\") {
			$fstring .= "\$'\\n'";
			$line = <$in>;
			chomp $line;
			next;
		} elsif ($char ne '#') {
			process(\$char, \$param, \$var, \$fstring, \$lvl);
		}
		$line =~ s/^\Q$text$match\E//;
	}
	$line =~ s/'/'\\''/g;
	$fstring .= "'$line'";
	my @vars = map "\"\$$_\"", 'a'..$var;
	print $out "echo $fstring\n";
	print $out "done\n" for 1..$lvl;
} while ($line = <$in>);

# close files
close $out;
close $in;

sub process {
	my $char    = shift;
	my $param   = shift;
	my $var     = shift;
	my $fstring = shift;
	my $lvl     = shift;
	#my ($char, $param, $var, $fstring, $lvl) = @_;
	if ($$char eq '$') {
		$$var = $$var ? ++$$var : 'a';
		print $out "echo \"\$$$param\" | while read $$var; do\n";
		$$fstring .= "\"\$$$var\"";
		$$lvl++;
	} elsif ($$char eq '/' or $$char eq '.') {
		$$var = $$var ? ++$$var : 'a' unless $$var =~ /^_/;
		$$param =~ s/'/'\\''/g;
		print $out "cat -- '$$char$$param' | while read $$var; do\n";
		$$fstring .= "\"\$$$var\"";
		$$lvl++;
	} elsif ($$char eq '!') {
		$$var = $$var ? ++$$var : 'a';
		print $out "( $$param ) | while read $$var; do\n";
		$$fstring .= "\"\$$$var\"";
		$$lvl++;
	} elsif ($$char eq '-') {
		$$var = $$var ? ++$$var : 'a';
		my $stdin = do { local $/; <STDIN> };
		$stdin =~ s/'/'\\''/g;
		print $out "echo -n '$stdin' | while read $$var; do\n";
		$$fstring .= "\"\$$$var\"";
		$$lvl++;
	} elsif ($$char eq '<') {
		$$param =~ /^(.)(.*)/;
		my $c = $1;
		my $p = $2;
		my $junk = "";
		process(\$c, \$p, \"_line", \$junk, $lvl);
		print $out "read -a _arr <<< \"\$_line\"\n";
	} elsif ($$char eq '0' and $$param eq "") { # {0}
		$$fstring .= "\"\$_line\"";
	} elsif ($$char =~ /[\d:]/) { # {N,N:,N:M,:M,...}
		for my $fields (split /,/, "$$char$$param") {
			if ($fields =~ /^(-?\d+)$/) {
				my $i = $1 - 1;
				$$fstring .= "\"\${_arr[$i]}\"";
			} elsif ($fields =~ /^(-?\d+):$/) {
				my $i = $1 - 1;
				$$fstring .= "\"\${_arr[@]:$i}\"";
			} else {
				my ($start, $end) = split /:/, $fields;
				$start ||= 1;
				$end ||= $start;
				$start -= 1;
				my $len = $end - $start;
				$$fstring .= "\"\${_arr[@]:$start:$len}\"";
			}
		}
	}
}
