#!/usr/bin/perl

use strict;
use warnings;

# define some vars
my $prog = (split(/\//, $0))[-1];
my $usage = "Syntax: $prog [SRC] [DEST]\n";

# export default env vars
$ENV{SEMPL_BRACES} ||= "{}";
$ENV{SEMPL_DUMP} ||= "";
$ENV{LB} = substr $ENV{SEMPL_BRACES},0,length($ENV{SEMPL_BRACES})/2;
$ENV{RB} = substr $ENV{SEMPL_BRACES},length($ENV{SEMPL_BRACES})/2,length($ENV{SEMPL_BRACES});
$ENV{LB} ||= $ENV{RB};

# parse args
my $src = shift || "-";
my $dest = shift || "-";

# make sure $src and $dest are not the same file
# TODO: make check works on windows
if (
	$^O ne "MSWin32"
	and $src ne "-"
	and $dest ne "-"
	and not $src =~ /\Q$ENV{LB}\E(.+?)\Q$ENV{RB}\E/
	and my ($dev1, $ino1) = (stat $dest)[0, 1]
) {
	my ($dev2, $ino2) = (stat $src)[0, 1] or die "$!";
	die "'$src' and '$dest' are the same file" if $dev1 == $dev2 && $ino1 == $ino2;
}

# open input file
my $in;
if ($src =~ /\Q$ENV{LB}\E(.+?)\Q$ENV{RB}\E/) {
	open($in, "<", \$src) or die $!;
} elsif ($src eq "-") {
	$in = \*STDIN or die $!;
} else {
	open($in, "<", $src) or die $!;
}

# process frontmatter
my $line = <$in> || "";
if ($line =~ /^#!.*$prog/) {
	while ($line = <$in>) {
		# export environment variables in frontmatter
		if ($line =~ /^#!.*$prog/) {
			# read first line of body and break loop
			$line = <$in>;
			last;
		} elsif ($line =~ /^#/) {
			next;
		} elsif ($line =~ /^\s*(.*?)\s*=\s*(.*)\s*$/) {
			my $key = $1;
			my $value = $2;
			if ($value =~ /^'(.*)'$/) {
				$value = $1;
				$value =~ s/'\\''/'/g;
			}
			$ENV{$key} = $value;
			next;
		} else {
			warn "Invalid line in frontmatter: \n\t$line\n";
		}
	}
}

# set env vars that frontmatter can't override
$ENV{DEST} = $dest;
$ENV{SRC} = $src;
$ENV{LB} = substr $ENV{SEMPL_BRACES},0,length($ENV{SEMPL_BRACES})/2;
$ENV{RB} = substr $ENV{SEMPL_BRACES},length($ENV{SEMPL_BRACES})/2,length($ENV{SEMPL_BRACES});
$ENV{LB} ||= $ENV{RB};

# open output handle
my $out;
if ($ENV{SEMPL_DUMP} and $dest eq "-") {
	# write shell script to stdout without executing it
	$out = \*STDOUT or die $!;
} elsif ($ENV{SEMPL_DUMP}) {
	# write shell script to dest.sh without executing it
	open($out, ">", $dest.".sh") or die $!;
} else {
	# run shell script directly
	open($out, "|-", "bash -e") or die "$!";
}

# send all output to dest
if ($dest ne "-") {
	print $out "exec >\"$dest\"\n";
}

# process template body
do {
	# tokenize string and process it
	my $var = '';
	my $fstring = '';
	my $lvl = 0;
	chomp $line;
	my $chars="#\$/.!<0-9:-";
	while ($line =~ /(\Q$ENV{LB}\E(\\{1,3})\Q$ENV{RB}\E$|\Q$ENV{LB}\E([$chars])(.*?)\Q$ENV{RB}\E)/pg) {
		my $match = $1;
		my $cont = $2;
		my $char = $3;
		my $param = $4;
		my $text = ${^PREMATCH};
		my $t = $text;
		$t =~ s/'/'\\''/g;
		$fstring .= "'$t'";
		if (defined $cont) {
			$line = <$in>;
			chomp $line;
			$line =~ s/^\s+// if $cont eq "\\\\\\";
			$fstring .= "\$'\\n'" if $cont eq "\\";
			next;
		} elsif (
			( $char eq '$' and not $param =~ /^[a-zA-Z_][a-zA-Z0-9_]*$/ )
			or ( $char eq '-' and $param ne "" )
		) {
			my $m = $match;
			$m =~ s/'/'\\''/g;
			$fstring .= "'$m'";
		} elsif ($char ne '#') {
			process(\$char, \$param, \$var, \$fstring, \$lvl);
		}
		$line =~ s/^\Q$text$match\E//;
	}
	$line =~ s/'/'\\''/g;
	$fstring .= "'$line'";
	my @vars = map "\"\$$_\"", 'a'..$var;
	print $out "echo $fstring\n";
	print $out "done\n" for 1..$lvl;
} while ($line = <$in>);

# close files
close $out;
close $in;

sub process {
	my $char    = shift;
	my $param   = shift;
	my $var     = shift;
	my $fstring = shift;
	my $lvl     = shift;
	#my ($char, $param, $var, $fstring, $lvl) = @_;
	if ($$char eq '$' and $$param =~ /^[a-zA-Z_][a-zA-Z0-9_]*$/) {
		warn "Unset environment variable: \$$$param\n" if not $ENV{$$param};
		$$var = $$var ? ++$$var : 'a' unless $$var =~ /^_/;;
		print $out "echo \"\$$$param\" | while IFS= read -r $$var; do\n";
		$$fstring .= "\"\$$$var\"";
		$$lvl++;
	} elsif ($$char eq '/' or $$char eq '.') {
		$$var = $$var ? ++$$var : 'a' unless $$var =~ /^_/;
		$$param =~ s/'/'\\''/g;
		print $out "cat -- '$$char$$param' | while IFS= read -r $$var; do\n";
		$$fstring .= "\"\$$$var\"";
		$$lvl++;
	} elsif ($$char eq '!') {
		$$var = $$var ? ++$$var : 'a' unless $$var =~ /^_/;;
		print $out "( $$param ) | while IFS= read -r $$var; do\n";
		$$fstring .= "\"\$$$var\"";
		$$lvl++;
	} elsif ($$char eq '-' and $$param eq "") {
		$$var = $$var ? ++$$var : 'a' unless $$var =~ /^_/;;
		my $stdin = do { local $/; <STDIN> };
		$stdin =~ s/'/'\\''/g;
		print $out "echo -n '$stdin' | while IFS= read -r $$var; do\n";
		$$fstring .= "\"\$$$var\"";
		$$lvl++;
	} elsif ($$char eq '<' and (
		$$param =~ /^[\/.!]/
		or $$param =~ /^\$[a-zA-Z_][a-zA-Z0-9_]*$/
		or $$param eq "-"
	) ) {
		$$param =~ /^(.)(.*)/;
		my $c = $1;
		my $p = $2;
		my $junk = "";
		process(\$c, \$p, \"_line", \$junk, $lvl);
		print $out "read -a _arr <<< \"\$_line\"\n";
	} elsif ($$char eq '0' and $$param eq "") { # {0}
		$$fstring .= "\"\$_line\"";
	} elsif ("$$char$$param" =~ /^(-?\d+:?|-?\d*:-?\d+)(,(-?\d+:?|-?\d*:-?\d+))*$/) { # {N,N:,N:M,:M,...}
		for my $fields (split /,/, "$$char$$param") {
			if ($fields =~ /^(-?\d+)$/) {
				my $i = $1 - 1;
				$$fstring .= "\"\${_arr[$i]}\"";
			} elsif ($fields =~ /^(-?\d+):$/) {
				my $i = $1 - 1;
				$$fstring .= "\"\${_arr[@]:$i}\"";
			} else {
				my ($start, $end) = split /:/, $fields;
				$start ||= 1;
				$end ||= $start;
				$start -= 1;
				my $len = $end - $start;
				$$fstring .= "\"\${_arr[@]:$start:$len}\"";
			}
		}
	} else {
		my $m = "$ENV{LB}$$char$$param$ENV{RB}";
		$m =~ s/'/'\\''/g;
		$$fstring .= "'$m'";
	}
}
