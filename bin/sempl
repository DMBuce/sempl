#!/usr/bin/perl

use strict;
use warnings;

# define some vars
my $prog = (split(/\//, $0))[-1];
my $usage = "Syntax: $prog [SRC] [DEST]\n";
my $ops = {
	'#' => \&processcomment,
	'$' => \&processenv,
	'/' => \&processfile,
	'.' => \&processfile,
	#'~' => \&processfile,
	'!' => \&processcmd,
	'-' => \&processstdin,
};

# export default env vars
$ENV{SEMPL_BRACES} ||= "{";
my $open  = substr $ENV{SEMPL_BRACES},0,length($ENV{SEMPL_BRACES})/2;
my $close = substr $ENV{SEMPL_BRACES},length($ENV{SEMPL_BRACES})/2,length($ENV{SEMPL_BRACES});

# parse args
my $src = shift || "-";
my $dest = shift || "-";

# open input file
my $in;
if ($src =~ /\Q$open\E(.+?)\Q$close\E/) {
	open($in, "<", \$src) or die $!;
} else {
	open($in, "<", $src) or die $!;
}

# process frontmatter
my $line = <$in>;
if ($line =~ /^#!.*$prog/) {
	while ($line = <$in>) {
		# export environment variables in frontmatter
		if ($line =~ /^#!.*$prog/) {
			# read first line of body and break loop
			$line = <$in>;
			last;
		} elsif ($line =~ /^#/) {
			next;
		} elsif ($line =~ /^\s*(.*?)\s*=\s*(.*)\s*$/) {
			my $key = $1;
			my $value = $2;
			if ($value =~ /^'(.*)'$/) {
				$value = $1;
				$value =~ s/'\\''/'/g;
			}
			$ENV{$key} = $value;
			if ($key eq "SEMPL_BRACES") {
				$open  = substr $ENV{SEMPL_BRACES},0,length($ENV{SEMPL_BRACES})/2;
				$close = substr $ENV{SEMPL_BRACES},length($ENV{SEMPL_BRACES})/2,length($ENV{SEMPL_BRACES});
			}
			next;
		} else {
			warn "Invalid line in frontmatter: \n\t$line\n";
		}
	}
}

# create pipe attached to sh that we can send our output to
open(my $out, "|-", "/bin/sh") or die "$!";

# send all output to dest
if ($dest ne "-") {
	print $out "exec >\"$dest\"\n";
}

# process template body
do {
	# tokenize string and process it
	my $var = '';
	my $fstring = '';
	my $lvl = 0;
	chomp $line;
	#while ($line =~ /(\Q$open\E(.)(.*?)\Q$close\E|\\(.))/pg) {
	while ($line =~ /(\Q$open\E(.)(.*?)\Q$close\E)/pg) {
		my $match = $1;
		my $char = $2;
		my $param = $3;
		#my $escape = $4;
		my $text = ${^PREMATCH};
		my $t = $text;
		$t =~ s/'/'\\''/g;
		$fstring .= "'$t'";
		if ($char eq '#') {
			# do nothing
		} elsif ($char eq '$') {
			$var = $var ? ++$var : 'a';
			print $out "echo \"\$$param\" | while read $var; do\n";
			$fstring .= "\"\$$var\"";
			$lvl++;
		} elsif ($char eq '/' or $char eq '.') {
			$var = $var ? ++$var : 'a';
			$param =~ s/'/'\\''/g;
			print $out "cat -- '$char$param' | while read $var; do\n";
			$fstring .= "\"\$$var\"";
			$lvl++;
		} elsif ($char eq '!') {
			$var = $var ? ++$var : 'a';
			print $out "( $param ) | while read $var; do\n";
			$fstring .= "\"\$$var\"";
			$lvl++;
		} elsif ($char eq '-') {
			$var = $var ? ++$var : 'a';
			my $stdin = do { local $/; <STDIN> };
			$stdin =~ s/'/'\\''/g;
			print $out "echo -n '$stdin' | while read $var; do\n";
			$fstring .= "\"\$$var\"";
			$lvl++;
		#} elsif ($escape) {
		#	$escape = "\n" if $escape eq "n";
		#	$escape = "\t" if $escape eq "t";
		#	$fstring .= "'$escape'";

		# TODO:
		# {<param} {N:M} {;}
		# while read -a $var; do
		# echo ${i[@]:N-1:M+1-N}
		}
		$line =~ s/^\Q$text$match\E//;
	}
	$line =~ s/'/'\\''/g;
	$fstring .= "'$line'";
	my @vars = map "\"\$$_\"", 'a'..$var;
	print $out "echo $fstring\n";
	print $out "done\n" for 1..$lvl;
} while ($line = <$in>);

# close files
close $out;
close $in;

