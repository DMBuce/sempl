#!/usr/bin/perl

use strict;
use warnings;

# define some vars
my $prog = (split(/\//, $0))[-1];
my $usage = "Syntax: $prog [SRC] [DEST]\n";
my $ops = {
	'#' => \&processcomment,
	'$' => \&processenv,
	'/' => \&processfile,
	'.' => \&processfile,
	#'~' => \&processfile,
	'!' => \&processcmd,
	'-' => \&processstdin,
};

# export default env vars
$ENV{SEMPL_OPEN} ||= "{";
$ENV{SEMPL_CLOSE} ||= "}";

# parse args
my $src = shift || "-";
my $dest = shift || "-";

# open input file
my $in;
if ($src =~ /\Q$ENV{SEMPL_OPEN}\E(.+?)\Q$ENV{SEMPL_CLOSE}\E/) {
	open($in, "<", \$src) or die $!;
} else {
	open($in, "<", $src) or die $!;
}

# process frontmatter
my $line = <$in>;
if ($line =~ /^#!.*$prog/) {
	while ($line = <$in>) {
		# export environment variables in frontmatter
		if ($line =~ /^#!.*$prog/) {
			# read first line of body and break loop
			$line = <$in>;
			last;
		} elsif ($line =~ /^#/) {
			next;
		} elsif ($line =~ /^\s*(.*?)\s*=\s*(.*)\s*$/) {
			my $key = $1;
			my $value = $2;
			if ($value =~ /^'(.*)'$/) {
				$value = $1;
				$value =~ s/'\\''/'/g;
			}
			$ENV{$key} = $value;
			next;
		} else {
			warn "Invalid line in frontmatter: \n\t$line\n";
		}
	}
}

# create pipe attached to sh that we can send our output to
open(my $out, "|-", "/bin/sh") or die "$!";

# send all output to dest
if ($dest ne "-") {
	print $out "exec >\"$dest\"\n";
}

# process template body
do {
	# tokenize string and process it
	my $var = '';
	my $fstring = '';
	my $lvl = 0;
	chomp $line;
	#while ($line =~ /(\Q$ENV{SEMPL_OPEN}\E(.)(.*?)\Q$ENV{SEMPL_CLOSE}\E|\\(.))/pg) {
	while ($line =~ /(\Q$ENV{SEMPL_OPEN}\E(.)(.*?)\Q$ENV{SEMPL_CLOSE}\E)/pg) {
		my $match = $1;
		my $char = $2;
		my $param = $3;
		#my $escape = $4;
		my $text = ${^PREMATCH};
		my $t = $text;
		$t =~ s/'/'\\''/g;
		$fstring .= "'$t'";
		if ($char) {
			$var = $var ? ++$var : 'a';
			$fstring .= "\"\$$var\"";
			$lvl += $ops->{$char}($char, $param, $var);
		#} elsif ($escape) {
		#	$escape = "\n" if $escape eq "n";
		#	$escape = "\t" if $escape eq "t";
		#	$fstring .= "'$escape'";
		}
		$line =~ s/^\Q$text$match\E//;
	}
	$line =~ s/'/'\\''/g;
	$fstring .= "'$line'";
	my @vars = map "\"\$$_\"", 'a'..$var;
	print $out "echo $fstring\n";
	print $out "done\n" for 1..$lvl;
} while ($line = <$in>);

# close files
close $out;
close $in;

sub processcomment {
	#my ($c, $param, $i) = @_;
	return 0;
}

sub processenv {
	my ($c, $param, $i) = @_;
	print $out "echo \"\$$param\" | while read $i; do\n";
	return 1;
}

sub processfile {
	my ($c, $param, $i) = @_;
	$param =~ s/'/'\\''/g;
	print $out "cat -- '$c$param' | while read $i; do\n";
	return 1;
}

sub processcmd {
	my ($c, $param, $i) = @_;
	print $out "( $param ) | while read $i; do\n";
	return 1;
}

sub processstdin {
	my ($c, $param, $i) = @_;
	local $/;
	my $stdin = <STDIN>;
	$stdin =~ s/'/'\\''/;
	print $out "echo -n '$stdin' | while read $i; do\n";
	return 1;
}

